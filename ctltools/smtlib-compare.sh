#!/usr/bin/env sh
#
# This script uses CVC3 to check the integrity of query results

. "$(readlink -f "$(dirname "$0")")/utils.sh"

DOCKER_DUMPPATH1='/host1'
DOCKER_DUMPPATH2='/host2'

# COMPARE ======================================================================

compare()
{
	case "$SOLVER" in
	z3)
		if ! is_command "$SOLVER"; then
			die 2 'Could not find Z3 installation on this system'
		fi
		SOLVER_BIN="$SOLVER"
		SOLVER_ARGS='-smt2'
		;;
	cvc3)
		SOLVER_BIN="$(find "$CHEFROOT_SRC" \
		              -name 'cvc3' \
		              -executable \
		              -type f)"
		if [ -z "$SOLVER_BIN" ]; then
			die 2 'Could not find CVC3 executable in project directory tree.'
		fi
		SOLVER_ARGS='-lang smt2'
		;;
	*)
		die_internal 'compare(): invalid solver %s' "$SOLVER"
		;;
	esac

	compare_wrong=0
	compare_array=''

	# List output comparison
	printf "query| orig  | comp\n"
	echo   '-----+-------+------'
	for i in $IDS_EXPANDED; do
		# original
		original_colour=''
		original="$("$SOLVER_BIN" \
		            $SOLVER_ARGS \
		            "$DUMPPATH1/$(printf "%06d" $i)")" \
		            || { original='error'; original_colour="\033[31m"; }

		# compact
		compact_colour="\033[32m"
		compact="$("$SOLVER_BIN" \
		           $SOLVER_ARGS \
		           "$DUMPPATH2/$(printf "%06d" $i)")" \
		           || { compact='invld'; compact_colour="\033[31m"; }

		# keep track
		if [ "$original" != "$compact" ]; then
			compare_wrong=$(($compare_wrong + 1))
			compare_array="$compare_array $i"
		fi

		# display
		printf "%6d | $original_colour%5s | $compact_colour%5s\033[0m\n" \
			$i "$original" "$compact"
	done 2>/dev/null
	echo '-----+-------+------'

	# Summary
	if [ $compare_wrong -eq 0 ]; then
		success "queries passed (%d)\n" $ID_COUNT
	else
		failure "queries failed (%d):%s\n" $compare_wrong "$compare_array"
	fi

	# Detailed output (if single)
	if [ $compare_wrong -eq 1 ] || [ $ID_COUNT -eq 1 ]; then
		emphasised $COLOUR_MISC "original:\n"
		"$SOLVER_BIN" \
			$SOLVER_ARGS \
			"$SRCPATH_ROOT/data/smtlibdump/$(printf "%06d" $i)"
		emphasised $COLOUR_MISC "compact:\n"
		"$SOLVER_BIN" \
			$SOLVER_ARGS \
			"$SRCPATH_ROOT/data/compactdump/$(printf "%06d" $i)"
	fi
}

# DRYRUN =======================================================================

dryrun()
{
	util_dryrun
	cat <<- EOF
	RANGE_OFFSET=$RANGE_OFFSET
	RANGE_LENGTH=$RANGE_LENGTH
	SOLVER=$SOLVER
	EOF
	exit 1
}

# DOCKER =======================================================================

docker_compare()
{
	docker run --rm -it \
		-v "$CHEFROOT":"$DOCKER_CHEFROOT" \
		dslab/s2e-chef:v0.6 \
		"$DOCKER_INVOKENAME" smtlib-compare \
			-s "$SOLVER" \
			"$DUMPNAME1":"$DUMPNAME2" \
			"$IDS"
}

# MAIN =========================================================================

usage()
{
	cat <<- EOF
	Usage: $INVOKENAME [OPTIONS ...] DUMP1:DUMP2 IDS
	EOF
}

help()
{
	usage

	cat <<- EOF

	Options:
	  -d           Dockerized (wrap execution inside docker container)
	  -h           Display this help and exit
	  -s {z3,cvc3} Use this solver [default=$SOLVER]
	  -y           Dry run: print variables and exit

	DUMP1:DUMP1
	  Names of the dumps generated by \`ctl smtlib-dump\`, whose SMTLIB queries
	  will be compared to each other.

	IDs:
	  The query IDs can be given as a comma-separated list of numbers or ranges,
	  where a range is two numbers separated by a dash (e.g. \`2,5,8-12\`)
	EOF
}

get_options()
{
	DRYRUN=$FALSE
	SOLVER='z3'

	while getopts :dhs:y opt; do
		case "$opt" in
			d) DOCKERIZED=$TRUE ;;
			h) help; exit 1 ;;
			s) SOLVER="$OPTARG" ;;
			y) DRYRUN=$TRUE ;;
			'?') die_help 'Invalid option: -%s' "$OPTARG";;
		esac
	done

	case "$SOLVER" in
		z3|cvc3) ;;
		stp) die 1 'This solver is not supported yet' ;;
		*) die_help 'Unknown solver: %s' "$SOLVER" ;;
	esac
	ARGSHIFT=$(($OPTIND - 1))
}

get_dumps()
{
	# TODO convert directories to dumps
	DIRS="$1"
	test -n "$DIRS" || die_help 'Missing directories'
	DUMPPATH1="$(readlink -f "$(echo "$DIRS" | cut -d ':' -f 1)")"
	DUMPPATH2="$(readlink -f "$(echo "$DIRS" | cut -d ':' -f 2)")"
	for dir in "$DUMPPATH1" "$DUMPPATH2"; do
		test -n "$dir" || die_help 'Missing directory'
		test -d "$dir" || die 2 '%s: Directory not found' "$dir"
		test -r "$dir" || die 3 '%s: permission denied' "$dir"
		if ! find "$dir"/*.smt >"$NULL" 2>"$NULL"; then
			die 2 "$dir does not seem to contain any SMT-LIB query dump files"
		fi
	done
	if [ "$DUMPPATH1" = "$DUMPPATH2" ]; then
		die_help 'Please specify a second, different directory'
	fi
	ARGSHIFT=1
}

get_ids()
{
	IDS="$1"
	test -n "$IDS" || die_help 'Missing ID list'
	IDS_EXPANDED="$(list_expand "$IDS")"
	IDS_EXPANDED="$(for id in $IDS_EXPANDED; do range_expand "$id"; done \
	                | uniq | sort -n)"
	ID_COUNT=$(echo "$IDS_EXPANDED" | wc -l)
	test -n "$IDS_EXPANDED" || die_help 'Invalid ID format'
	ARGSHIFT=1
}

main()
{
	get_options "$@"
	shift $ARGSHIFT
	get_directories "$@"
	shift $ARGSHIFT
	get_ids "$@"
	shift $ARGSHIFT
	test $# -eq 0 || die_help "trailing arguments: $@"

	if [ $DRYRUN -eq $TRUE ]; then
		dryrun
		exit
	fi

	if [ $DOCKERIZED -eq $TRUE ]; then
		docker_compare
	else
		compare
	fi
}

set -e
main "$@"
set +e
